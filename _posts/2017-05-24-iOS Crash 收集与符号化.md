---
layout: post
title: iOS Crash 收集与符号化
categories: blog
description: 符号化
keywords: Symbolicatecrash
---        
硌，当我们提交到AppStore 上的app 崩溃了，我想此时我们的内心也是崩溃的。此时，我们应该做的就是赶紧从iTunes store上下载crash log。可是crash log下载下来了，怎么知道crash log 和我们的二进制是对应的呢。               
每一个二进制都一个UUID，crash log 也包含一个UUID。那这两个UUID 有什么联系呢          
>注意：即使是相同的代码，相同的编译设置,重新编译也会产生不同的UUID。          



废话不多说，先来看看crash文件       
````
$ grep --after-context=2 "Binary Images:" ~/Desktop/crashlog/QQMusic.crash      
Binary Images:       
0x10004c000 - 0x102c57fff QQMusic arm64  <813351adc3743903b832ded6e23e7d62> /var/mobile/Containers/Bundle/Application/D4303251-B98D-4AAD-AA58-34E6478A0011/QQMusic.app/QQMusic        
0x103804000 - 0x103807fff MobileSubstrate.dylib arm64  <3134cfb2f722310ea2c742ae4dc131ab> /Library/MobileSubstrate/MobileSubstrate.dylib      
````


此时的 <b>813351adc3743903b832ded6e23e7d62</b> 就是这份crash log 对应的二级制的UUID了。再来看看二进制的UUID。
```
$ xcrun dwarfdump --uuid qqmusic/Payload/QQMusic.app/QQMusic
UUID: 10D3D53D-CA6D-30D0-99FA-80468D423359 (armv7) qqmusic/Payload/QQMusic.app/QQMusic
UUID: 813351AD-C374-3903-B832-DED6E23E7D62 (arm64) qqmusic/Payload/QQMusic.app/QQMusic
```
这个app有2个UUID，表明它是一个fat binaray


我们知道APP启动都有一个模块加载地址和偏移地址，他们的关系是怎么样的呢。下面用一张图来说明：
```
Last Exception Backtrace:
0   CoreFoundation 0x000000018708b100 0x186f80000 + 1093888
1   libobjc.A.dylib            0x00000001939441fc 0x19393c000 + 33276
2   CoreFoundation 0x000000018708b040 0x186f80000 + 1093696
3   ApteligentExampleApp 0x000000010003acc4 0x10002c000 + 60612
```

```
Binary Images:
0x10002c000 - 0x1000dffff ApteligentExampleApp arm64  <3759a98e880336108b1a799afa3c1adc> /var/mobile/Applications/46FB38F8-0E69-459F-B96A-CEEA21B77D55/ApteligentExampleApp.app/ApteligentExampleApp
```


![](/images/blog/loadAddressAndSlide.png)


有了这些概念后，我们就来分析crash log 了。



<h4>符号化你的crash log</h4>
当你获取到了crash log，相对应的二进制文件，符号化文件，三者都对应后，使用以下命令，直接一键符号化。
```
atos -arch <Binary Architecture> -o <Path to dSYM file>/Contents/Resources/DWARF/<binary image name> -l <load address> <address to symbolicate>
```
如上图：



```
atos -arch arm64 -o ApteligentExampleApp.dSYM -l 0x10002c000 0x000000010003acc4
-[ApteligentExampleClass buggyFunction] (in ApteligentExampleApp.dSYM) (ApteligentExampleClass.m:181)
```

这没什么问题。



有时候，我们想偷个懒，没有必要恢复怎么符号表，只要稍微给点信息，我们就解决，我只想看看crash 在哪个函数中。


比如有这么一段崩溃信息：
```
16  CoreFoundation                	0x183fddcd8 __CFRunLoopRun + 724
17  CoreFoundation                	0x183f0cca0 CFRunLoopRunSpecific + 384
18  UIKit                         	0x18962a1c8 -[UIApplication _run] + 460
19  UIKit                         	0x189624ffc UIApplicationMain + 204
20  DemoSandbox                   	0x1000e82a0 0x1000e0000 + 33440
21  libdyld.dylib                 	0x19933a8b8 start + 4
```


```
Binary Images:
0x1000e0000 - 0x1000ebfff DemoSandbox arm64  <a913f9e410ab3389a4bb7a03c4343d60> /var/mobile/Containers/Bundle/Application/7839DCA5-8955-4796-8142-6932ACDB873A/DemoSandbox.app/DemoSandbox
```

这样我们看的更清楚，0x1000e0000就是我们模块的加载地址


接下来我们在没有符号文件的情况下来看看

```
$ atos -arch arm64 -o /Users/heyonly/Library/Developer/Xcode/DerivedData/emm-gcfmioqsbcxmerceaefbrzjkatft/Build/Products/Debug-iphoneos/DemoSandbox.app/DemoSandbox -l 0x1000e0000 0x1000e82a0
main (in DemoSandbox) (main.m:14)
```

这样是不是很清晰明了



有人就会说，我们开发的我们都会有符号文件。嗯，有一种情况会用的到，在做非越狱手机进行开发的时候很管用
为此，我专门谢了个脚本





项目地址：<a>https://github.com/heyonly/hbsymbolicate</a>



很方便：
```
sh symbol.sh -l <path/ipa.crash> -b <path/example.app/example> -o destination.crash
```

不是很好用，我有时间会来优化优化




<h4>总结</h4>

有点乱，慢慢就会好了，欢迎拍砖



参见：

<a>[1]:https://www.apteligent.com/technical-resource/symbolicating-an-ios-crash-report/</a>
<a>[2]:https://developer.apple.com/library/content/technotes/tn2151/_index.html</a>
<a>[3]:https://developer.apple.com/library/content/technotes/tn2151/_index.html</a>