---
layout: post
title: 汇编学习笔记
categories: blog
description: ARM 汇编学习笔记
keywords: 汇编，ARM汇编
---

最近在做技术攻关的时候，遇到一些问题很诡异。从源码看起来完全没有问题。这就有点头疼，无奈，只能从汇编看了。用汇编结合lldb 的调试技巧，成果还不错，总有一些突破。




学习汇编并没有想象的那么难，我们学习汇编，并不是要我们拿汇编来写程序，只是帮助我们定位问题所在，还可以帮助我们更加深刻的理解计算机。




<h5>工具</h5>
如果我们有源码就能解决的问题，又何须去看汇编呢。汇编不是你想看就能看的，因此我们需要一些反汇编的工具来辅助我们进行汇编代码查看。我推荐几个工具：`Hopper Disassembler` 收费应用、`IDA Pro` 也是收费应用，这两个工具看起来确实方便。还有不要忘了，Xcode 本身给我们带的工具:`lldb`



```
(lldb) disassemble
pthreadtest`main:
    0x100000960 <+0>:   push   rbp
    0x100000961 <+1>:   mov    rbp, rsp
    0x100000964 <+4>:   sub    rsp, 0xc0
    0x10000096b <+11>:  lea    rax, [rip + 0x10ee]       ; empty_sem
```


效果也差不多，掌握一些调试技巧，这个还能动态调试。




<h5>寄存器</h5>
寄存器是CPU中的高速存储单元，要比内存中存取要快的多的一些存储单元，至于为什么比内存快，建议看看这篇文章 [为什么寄存器比内存快？](http://www.ruanyifeng.com/blog/2013/10/register.html),让我大开眼界。寄存器总共分为：通用寄存器、专用寄存器和控制寄存器。



<h5>理论联系实际</h5>
```
(lldb) register read
General Purpose Registers:
        x0 = 0x0000000010004005
        x1 = 0x0000000007000806
        x2 = 0x0000000000000000
        x3 = 0x0000000000000c00
        x4 = 0x0000000000002303
        x5 = 0x00000000ffffffff
        x6 = 0x0000000000000000
        x7 = 0x0000000000000001
        x8 = 0x00000000fffffbbf
        x9 = 0x0000000007000000
       x10 = 0x0000000007000100
       x11 = 0x0000000000041f88
       x12 = 0x00005e0000005f03
       x13 = 0x0000000000000000
       x14 = 0x00005f0000005f00
       x15 = 0x0000000000000000
       x16 = 0xffffffffffffffe1
       x17 = 0x00000001892ab2a4  CoreFoundation`-[__NSArrayM count]
       x18 = 0x0000000000000000
       x19 = 0x0000000000000000
       x20 = 0x00000000ffffffff
       x21 = 0x0000000000002303
       x22 = 0x0000000000000c00
       x23 = 0x000000016fd7eca8
       x24 = 0x0000000007000806
       x25 = 0x0000000000000000
       x26 = 0x0000000007000806
       x27 = 0x0000000000000c00
       x28 = 0x0000000000000001
        fp = 0x000000016fd7ebb0
        lr = 0x00000001883ab09c  libsystem_kernel.dylib`mach_msg + 72
        sp = 0x000000016fd7eb60
        pc = 0x00000001883ab224  libsystem_kernel.dylib`mach_msg_trap + 8
      cpsr = 0x60000000
```



* R0 - R30



R0 - R30 是31个通用整形寄存器。每个寄存器可以存取一个64位大小的数。当使用x0 - x30 访问时，他就是一个64位的数，当使用w0 - w30 访问时，访问的是这些寄存器的低32 位。




其实通用寄存器有32个，低32个寄存器x31 ，在指令编码中，使用来做`zero register`，即`ZR`，`XZR/WZR` 分别代表64/32位，`zero register `的作用就是0，写进去代表丢弃结果，拿出来是0.




其中`r29` 又被叫做`fp`（frame pointer），`r30`又被叫做`lr` (link register).


* SP


SP 寄存器其实就是x31 ,在指令编码中，使用`SP/WSP` 来进行对SP寄存器的访问。



* PC



PC 寄存器存的是当前执行的指令的地址




* SPRs



SPRs是状态寄存器，用于存放程序运行中的一些状态标识，根据状态寄存器中的一些状态来控制分支的执行。状态寄存器又分为 `The Current Program Status Register (CPSR)` 和 `The Saved Program Status Registers (SPSRs)`。 一般都是使用`CPSR`， 当发生异常时， `CPSR`会存入`SPSR`。当异常恢复，再拷贝回`CPSR`


* V0 - V31



V0 - V31 是向量寄存器，也可以说是浮点型寄存器。它的特点是每个寄存器的大小是 128 位的。 分别可以用Bn Hn Sn Dn Qn的方式来访问不同的位数



* 一般来说，arm64 上x0 - x7 分别会存放方法的前8个参数
* 如果方法的参数个数超过8个，多余的参数会存放在栈上，新方法会通过栈来读取。
* 方法的返回值一般都在x0 上。x86 的方法返回值会存放在`eax`上
* 如果方法返回值是一个较大的数据结构时，结果会存放在x8 执行的地址上。





