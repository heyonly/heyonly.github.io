---
layout: post
title: iOS之lldb 调试技巧 
categories: blog
description: lldb 的调试技巧
keywords: lldb
---
<h2>前言</h2>



在程序员的路上，bug 总是伴随而行，遇到bug 怎么办？当然是解决啦，解决bug 调试必不可少，。工欲善其事，必先利其器，今天来说说iOS的额调试：lldb         



自己开发的，有源码，直接使用xcode 进入调试模式即可，没什么好讲的。当看到别人开发的APP，我们想学习学习，想一探究竟怎么办呢。今天讲讲怎么调试别人的APP。




废话不多说，开始

<h4>准备工作</h4>
```
MacPro$ ls /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport/
硌，你会看到以下结果
10.0/         10.2 (14C89)/ 8.1/          8.3/          9.0/          9.2/         
10.1/         8.0/          8.2/          8.4/          9.1/          9.3/

```
选择一个版本，适合你的iOS系统的，


```
$ hdiutil attach /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport/10.3\ \(14E269\)/DeveloperDiskImage.dmg
Checksumming whole disk (Apple_HFS : 0)…
.....................................................................................................................................
          whole disk (Apple_HFS : 0): verified   CRC32 $2C5704DD
verified   CRC32 $3E5D9CC2
/dev/disk2          	                               	/Volumes/DeveloperDiskImage
```
```
$ ls /Volumes/DeveloperDiskImage/usr/bin/
DTDeviceArbitration	XcodeDeviceMonitor	debugserver		xctest
ScreenShotr		axauditd		iprofiler
```

这时在/Volumes/DeveloperDiskImage/usr/bin/ 看到debugserver 了


```
MacPro$ codesign -s - --entitlements entitlements.plist -f debugserver
```
entilements.plist 的内容如下
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/ PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.springboard.debugapplications</key> <true/>
    <key>run-unsigned-code</key> <true/>
    <key>get-task-allow</key> <true/>
    <key>task_for_pid-allow</key> <true/>
</dict> 
</plist>
```
然后把debugserver 拷贝到手机上
```
MacPro$ scp ./debugserver root@192.168.0.101:/usr/bin/
```


慢着，记得看看debugserver 的权限


```
#chmod +x /usr/bin/debugserver
```
```
# debugserver *:6666 -a Preferences
```
嗯，等个1分钟就可以了
```
$ lldb
(lldb) platform select remote-ios
(lldb) process connect connect://192.168.0.101:6666

debugserver-310.2 for armv7.
Attaching to process Preferences...
Listening to port 6666 for a connection from *...
```

嗯，这里等了几分钟终于看到结果了。


![](/images/blog/f7c13212b5c3b9918ff4e6f70a3095d0.gif)



几分钟，小编，你搞事情啊，有没有能快点的方法








下面来介绍一种快速的方法：通过USB来调试



*下载usbmuxd :[https://github.com/libimobiledevice/usbmuxd](https://github.com/libimobiledevice/usbmuxd) 或者 :[http://iphonedevwiki.net/index.php/SSH_Over_USB#Using_python](http://iphonedevwiki.net/index.php/SSH_Over_USB#Using_python) 安装好。



打开终端



```
$ iproxy 6666 6666
```

```
(lldb) process connect connect://localhost:6666
```


```
$ ssh root@localhost -p 2222
root@localhost's password: 
```




###Starting debuging


如果你想调试的APP 正在运行


```
# ps -ax 
  PID TTY           TIME CMD
    ...
 2953 ??         0:02.27 /Applications/MobileSMS.app/MobileSMS
    ...
```

通过pid attach



```
# debugserver *:6666 -a 2953
```
或者




```
# debugserver *:6666 -a MobileSMS
```



在你mac上



```
(lldb) platform select remote-ios
(lldb) process connect connect://192.168.0.101:6666
```



或者USB的方式



```
(lldb) platform select remote-ios
(lldb) process connect connect://localhost:6666
```



如果APP还没有运行



```
# debugserver *:6666 -waitfor MobileSMS
```



```
(lldb) platform select remote-ios
(lldb) process connect connect://192.168.0.101:6666
```
或者



```
(lldb) platform select remote-ios
(lldb) process connect connect://localhost:6666
```



还有一种情况，我们想调试APP的启动过程

```
# debugserver *:6666 -x backboard /Applications/MobileSMS.app/MobileSMS
```
或者



```
# find /private/var/mobile/Containers/Bundle/Application  -name "QQMusic"
/private/var/mobile/Containers/Bundle/Application/49737E0A-343F-447B-B863-4866E7BE7727/QQMusic.app/QQMusic

# debugserver *:1234 -x backboard /private/var/mobile/Containers/Bundle/Application/49737E0A-343F-447B-B863-4866E7BE7727/QQMusic.app/QQMusic
debugserver-@(#)PROGRAM:debugserver  PROJECT:debugserver-320.2.89
 for arm64.
Listening to port 1234 for a connection from *…
```


```
The -x parameter can be one of:

auto: Auto-detect the best launch method to use.
fork: Launch program using fork() and exec().
posix: Launch program using posix_spawn().
backboard: Launch program via BackBoard Services.
Note! Always use backboard to start iOS GUI applications! 
```



同样在你的mac上启动lldb



```
(lldb) platform select remote-ios
(lldb) process connect connect://192.168.0.101:6666
```
或者



```
(lldb) platform select remote-ios
(lldb) process connect connect://localhost:6666
```



*有可能你在连接的时候报
```
(lldb) process connect connect://localhost:6666
error: failed to get reply to handshake packet
```



把你的程序手动杀死一遍或者kill -9 WeChat




```
(lldb) image list
[  0] D4078742-B857-3661-B9FE-465518CAED3C 0x0000000120080000 /Users/uusafe/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/usr/lib/dyld
```


你没看错，我的qq 音乐就只加载了这么个东西
其他的怎么加载呢


Use the following commands to load all images:



```
(lldb) settings set target.process.stop-on-sharedlibrary-events 1
(lldb) c
(lldb) settings set target.process.stop-on-sharedlibrary-events 0
(lldb) image list
[  0] 813351AD-C374-3903-B832-DED6E23E7D62 0x0000000100010000 /var/mobile/Containers/Bundle/Application/49737E0A-343F-447B-B863-4866E7BE7727/QQMusic.app/WeChat (0x0000000100010000)
[  1] D4078742-B857-3661-B9FE-465518CAED3C 0x0000000120080000 /Users/uusafe/Library/Developer/Xcode/iOS DeviceSupport/9.1 (13B143)/Symbols/usr/lib/dyld
```




接下来我们看看lldb 的命令



```
# debugserver *:6666 -a WeChat
debugserver-@(#)PROGRAM:debugserver  PROJECT:debugserver-340.3.124
 for arm64.
Attaching to process WeChat...
Listening to port 6666 for a connection from *...
Waiting for debugger instructions for process 0.
```



```
$ lldb
(lldb) process connect connect://localhost:6666
Process 690 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP
    frame #0: 0x00000001983dca40 libsystem_kernel.dylib`mach_msg_trap + 8
libsystem_kernel.dylib`mach_msg_trap:
->  0x1983dca40 <+8>: ret    

libsystem_kernel.dylib`mach_msg_overwrite_trap:
    0x1983dca44 <+0>: mov    x16, #-0x20
    0x1983dca48 <+4>: svc    #0x80
    0x1983dca4c <+8>: ret
```



```
(lldb) thread backtrace 
* thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP
  * frame #0: 0x00000001983dca40 libsystem_kernel.dylib`mach_msg_trap + 8
    frame #1: 0x00000001983dc8bc libsystem_kernel.dylib`mach_msg + 72
    frame #2: 0x0000000182f80108 CoreFoundation`__CFRunLoopServiceMachPort + 196
    frame #3: 0x0000000182f7de0c CoreFoundation`__CFRunLoopRun + 1032
    frame #4: 0x0000000182eacca0 CoreFoundation`CFRunLoopRunSpecific + 384
    frame #5: 0x000000018e0e8088 GraphicsServices`GSEventRunModal + 180
    frame #6: 0x00000001885c4ffc UIKit`UIApplicationMain + 204
    frame #7: 0x00000001000dbea4 WeChat`-[WATemplateMsgMngSwitchCell .cxx_destruct] + 372
    frame #8: 0x00000001982da8b8 libdyld.dylib`start + 4
```



看到当前主线程中，还有各个frame的状态


我们再看看微信当前的UI结构：


```
(lldb) po [[UIApplication sharedApplication] keyWindow]
<iConsoleWindow: 0x15e797a10; baseClass = UIWindow; frame = (0 0; 320 568); autoresize = W+H; gestureRecognizers = <NSArray: 0x15e7999b0>; layer = <UIWindowLayer: 0x15e794520>>

(lldb) po [[[UIApplication sharedApplication] keyWindow] rootViewController]
<MMTabBarController: 0x15f0c4600>
```


我们从上面的结果来看，知道微信的大致结构了(你这不废话吗，我不用调试我也知道)。



####breakpoint 命令



可以根据函数名设置断点：



```
(lldb) breakpoint set --name main
(lldb) br s -n main
(lldb) b main
```

```
(lldb) breakpoint set --method main
(lldb) br s -M main
```

可以根据文件名，代码行数设置断点：

```
(lldb) breakpoint set --file test.c --line 12
(lldb) br s -f test.c -l 12
(lldb) b test.c:12
```



对于OC：


```
(lldb) breakpoint set --name "-[NSString stringWithFormat:]"
(lldb) b -[NSString stringWithFormat:]
```


也可以


```
(lldb) breakpoint set --selector count
(lldb) br s -S count
```


查看所有断点：
```
(lldb) breakpoint set -name sendAction:to:from:forEvent:
Breakpoint 1: where = UIKit`-[UIApplication sendAction:to:from:forEvent:], address = 0x0000000188593c98
(lldb) br list 
Current breakpoints:
1: name = 'sendAction:to:from:forEvent:', locations = 1, resolved = 1, hit count = 0
  1.1: where = UIKit`-[UIApplication sendAction:to:from:forEvent:], address = 0x0000000188593c98, resolved, hit count = 0 

(lldb) br l
Current breakpoints:
1: name = 'sendAction:to:from:forEvent:', locations = 1, resolved = 1, hit count = 0
  1.1: where = UIKit`-[UIApplication sendAction:to:from:forEvent:], address = 0x0000000188593c98, resolved, hit count = 0
```


删除断点：


```
(lldb) breakpoint delete 1
(lldb) br del 1

```
####print 命令


可能print 命令是我们在平时开发中使用频率最高的了.
输入help  print
```
'print' is an abbreviation for 'expression --'
```

我们平时打印对象时会使用po(print object） 其实就是expression -o --的缩写


```
(lldb) po @[@"1",@"2"]
<__NSArrayI 0x12795b4d0>(
1,
2
)


(lldb) expression -o -- @[@"1",@"2"]
<__NSArrayI 0x127bc7de0>(
1,
2
)
```

会得到同样的结果。


同样我们要打印一个对象。我们更喜欢直接使用po 而不是expression -o --



```
(lldb) po [[UIApplication sharedApplication] delegate]
<MicroMessengerAppDelegate: 0x126798290>
```


另外，可以给 print 指定不同的打印格式。它们都是以 print/<fmt> 或者简化的 p/<fmt> 格式书写。下面是一些例子：



```
(lldb) p 16
(int) $7 = 16
(lldb) p/x 16
(int) $8 = 0x00000010
(lldb) p/t 16
(int) $9 = 0b00000000000000000000000000010000
```



####expression



expression 的作用当然不只是打印一个对象，比如说



```
(lldb) po [[[[UIApplication sharedApplication] keyWindow] rootViewController] class]
MMTabBarController
```



和



```
(lldb) expression id $ret = (id)[[[UIApplication sharedApplication] keyWindow] rootViewController]
(lldb) po [$ret class]
MMTabBarController

```



![](/images/blog/591cf8e331311.jpg)



嗯，就是有这种操作。


再来个神级的操作:
```
(lldb) po [$ret _shortMethodDescription]
<MMTabBarController: 0x126883000>:
in MMTabBarController:
	Properties:
		@property (weak, nonatomic) <MMTabBarControllerDelegate>* delegate;
	Instance Methods:
		- (id) currentViewController; (0x101c38bb4)
		- (id) getViewControllerAtIndex:(unsigned int)arg1; (0x101c38bc0)
```



嗯，是的，所有方法和属性都打印出来了。



当然你也可以像写程序一样来：
```
(lldb) expression char* $str = (char*)malloc(sizeof(char)*8)
(lldb) expression (void*)memset($str,0,8)
(void *) $11 = 0x00000001267ab9b0
(lldb) expression (void*)memcpy((void*)$str,(void*)"1234567",7)
(void *) $12 = 0x00000001267ab9b0
(lldb) p (char*)$str
(char *) $13 = 0x00000001267ab9b0 "1234567"
(lldb) expression (void)free((void*)$str)
```


当然还有很多其他的操作，可以使用



```
(lldb) help expression
```


来查看，讲的非常详细



####thread


有时候，我们想了解线程堆栈信息，可以使用thread backtrace，thread backtrace 的作用是将线程的堆栈信息打印出来


```
(lldb) help thread
     Commands for operating on one or more threads in the current process.

Syntax: thread <subcommand> [<subcommand-options>]
```


当发生crash的时候，我们可以使用thread backtrace 查看堆栈调用信息


```
(lldb) thread backtrace 
* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step into
  * frame #0: 0x00000001983dc8c8 libsystem_kernel.dylib`mach_msg + 84
    frame #1: 0x0000000182f80108 CoreFoundation`__CFRunLoopServiceMachPort + 196
    frame #2: 0x0000000182f7de0c CoreFoundation`__CFRunLoopRun + 1032
    frame #3: 0x0000000182eacca0 CoreFoundation`CFRunLoopRunSpecific + 384
    frame #4: 0x000000018e0e8088 GraphicsServices`GSEventRunModal + 180
    frame #5: 0x00000001885c4ffc UIKit`UIApplicationMain + 204
    frame #6: 0x0000000100157ea4 WeChat`-[WATemplateMsgMngSwitchCell .cxx_destruct] + 372
    frame #7: 0x00000001982da8b8 libdyld.dylib`start + 4
```


有时候，我们并不想让代码执行，只需要返回一个结果就好了，比如：



```
(lldb) thread return NO
```


具体的看help thread 吧，很详细.



####frame


有时候，我们想查看线程中的调用栈是什么样的，有时候我们经常查看变量的值
```
(lldb) frame variable
(ViewController *) self = 0x00007f84fed03df0
(SEL) _cmd = "viewDidLoad"
(NSArray *) array = 0x3ff0000000000000
```


查看当前frame的信息：
```
(lldb) frame info
frame #0: 0x0000000104938b51 DemoSandbox`::-[ViewController viewDidLoad](self=0x00007f84fed03df0, _cmd="viewDidLoad") at ViewController.mm:38
```

有时候，由于某种原因，我们想观察的变量或者返回值过了，但是再来调试又麻烦，怎么办，
这时就有一个非常好的命令
```
(lldb) bt
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1
  * frame #0: 0x0000000104938b9e DemoSandbox`::-[ViewController viewDidLoad](self=0x00007f84fed03df0, _cmd="viewDidLoad") at ViewController.mm:40
    frame #1: 0x0000000105ecbcca UIKit`-[UIViewController loadViewIfRequired] + 1235
    ......
```

```
(lldb) frame select 1
frame #1: 0x000000010a00fcca UIKit`-[UIViewController loadViewIfRequired] + 1235
UIKit`-[UIViewController loadViewIfRequired]:
    0x10a00fcca <+1235>: mov    eax, dword ptr [r14]
    0x10a00fccd <+1238>: test   eax, eax
    0x10a00fccf <+1240>: je     0x10a00fcdd               ; <+1254>
    0x10a00fcd1 <+1242>: cmp    eax, 0x70000
```

把程序状态倒回去，方便我们查看。


```
(lldb) frame info
frame #1: 0x000000010a00fcca UIKit`-[UIViewController loadViewIfRequired] + 1235
```



当然还有很多其他方法，等用到的时候再去看，大多数时候是用不到的。



####breakpoint command



























